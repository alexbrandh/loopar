<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Test AR Simple</title>
    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.4.5/aframe/build/aframe-ar-nft.js"></script>
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            overflow: hidden;
            background: black;
        }
        
        #info {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 10px;
            border-radius: 5px;
            z-index: 1000;
            font-size: 12px;
            max-width: 300px;
        }
        
        #debug {
            position: fixed;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 10px;
            border-radius: 5px;
            z-index: 1000;
            font-size: 10px;
            max-width: 300px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        /* Force A-Frame scene to fill entire viewport */
        a-scene {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            margin: 0 !important;
            padding: 0 !important;
            border: none !important;
            background: transparent !important;
        }
        
        /* Ensure AR video fills the screen */
        #arjs-video {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            object-fit: cover !important;
            z-index: -1 !important;
            background: black !important;
        }
        
        /* Make canvas transparent and on top */
         canvas.a-canvas {
             position: fixed !important;
             top: 0 !important;
             left: 0 !important;
             width: 100vw !important;
             height: 100vh !important;
             background: transparent !important;
             background-color: transparent !important;
             z-index: 1 !important;
             pointer-events: auto !important;
         }
         
         /* Force canvas transparency with multiple selectors */
         canvas, canvas.a-canvas, .a-canvas {
             background: transparent !important;
             background-color: transparent !important;
             background-image: none !important;
             pointer-events: none !important;
             mix-blend-mode: multiply !important;
         }
         
         /* Override any A-Frame default styles */
         a-scene canvas {
             background: transparent !important;
             background-color: transparent !important;
             pointer-events: none !important;
         }
         
         /* Ensure AR video is always visible */
         #arjs-video {
             position: fixed !important;
             top: 0 !important;
             left: 0 !important;
             width: 100vw !important;
             height: 100vh !important;
             object-fit: cover !important;
             z-index: -1 !important;
             background: black !important;
             display: block !important;
             visibility: visible !important;
             opacity: 1 !important;
             margin: 0 !important;
             padding: 0 !important;
             border: none !important;
             outline: none !important;
         }
        
        /* Hide any white backgrounds */
        .a-enter-vr, .a-orientation-modal {
            display: none !important;
        }
    </style>
</head>
<body>
    <div id="info">
        <strong>Test AR Simple</strong><br>
        Estado: <span id="status">Inicializando...</span><br>
        C√°mara: <span id="camera-status">Verificando...</span><br>
        Tracking: <span id="tracking-status">No detectado</span>
    </div>
    
    <div id="debug">
        <strong>Debug Log:</strong><br>
        <div id="debug-log"></div>
    </div>

        <a-scene
        vr-mode-ui="enabled: false"
        renderer="logarithmicDepthBuffer: true; antialias: true; colorManagement: true; alpha: true; preserveDrawingBuffer: true;"
        arjs="trackingMethod: best; sourceType: webcam; debugUIEnabled: false; detectionMode: mono_and_matrix; matrixCodeType: 3x3; maxDetectionRate: 20; smooth: true; smoothCount: 3; smoothTolerance: 0.02; smoothThreshold: 3; displayWidth: 640; displayHeight: 480;"
        embedded
        style="height: 100vh; width: 100vw;"
    >
        <a-assets timeout="30000">
            <video
                id="vid"
                src="/videos/sample-video.mp4"
                preload="metadata"
                loop
                autoplay
                muted
                playsinline
                controls="false"
                webkit-playsinline="true"
                width="320"
                height="240"
                crossorigin="anonymous"
            ></video>
        </a-assets>

        <!-- Usar descriptores NFT de prueba de AR.js -->
        <a-nft
          type="nft"
          url="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.4.5/data/dataNFT/pinball"
          smooth="true"
          smoothCount="5"
          smoothTolerance="0.01"
          smoothThreshold="2"
          emitevents="true"
          id="nft-marker"
          videohandler
        >
          <!-- NUEVA ESTRATEGIA: Usar transform matrix directo -->
          <a-plane
            src="#vid"
            position="300 0 0.1"
            rotation="-90 0 0"
            width="150"
            height="267"
            material="shader: flat; transparent: false; side: double;"
            visible="true"
            id="video-plane"
            animation="property: object3D.position.x; to: 300; dur: 1; easing: linear; loop: false"
          ></a-plane>
        </a-nft>

        <a-entity camera look-controls-enabled="false"></a-entity>
    </a-scene>

    <script>
        const statusEl = document.getElementById('status');
        const cameraStatusEl = document.getElementById('camera-status');
        const trackingStatusEl = document.getElementById('tracking-status');
        const debugLogEl = document.getElementById('debug-log');
        
        function log(message) {
            console.log(message);
            debugLogEl.innerHTML += message + '<br>';
            debugLogEl.scrollTop = debugLogEl.scrollHeight;
        }
        
        function updateStatus(status) {
            statusEl.textContent = status;
            log(`Status: ${status}`);
        }
        
        function updateCameraStatus(status) {
            cameraStatusEl.textContent = status;
            log(`Camera: ${status}`);
        }
        
        function updateTrackingStatus(status) {
            trackingStatusEl.textContent = status;
            log(`Tracking: ${status}`);
        }
        
        // Verificar acceso a c√°mara
        async function checkCamera() {
            try {
                updateCameraStatus('Solicitando acceso...');
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                updateCameraStatus('‚úÖ Acceso concedido');
                stream.getTracks().forEach(track => track.stop());
                return true;
            } catch (error) {
                updateCameraStatus('‚ùå Error: ' + error.message);
                return false;
            }
        }
        
        // Funci√≥n para forzar posici√≥n del video independientemente del marcador
        function forceVideoPosition() {
            const aPlane = document.querySelector('#video-plane');
            
            if (aPlane) {
                log('üîß AJUSTANDO POSICI√ìN - X = 300');
                
                // M√©todo 1: Usar matrix transform directo en Three.js X = 300
                if (aPlane.object3D) {
                    // Resetear completamente la matriz de transformaci√≥n
                    aPlane.object3D.matrix.identity();
                    aPlane.object3D.position.set(300, 0, 0.1); // X = 300
                    aPlane.object3D.rotation.set(-Math.PI/2, 0, 0);
                    aPlane.object3D.scale.set(2, 2, 2); // Escala reducida
                    aPlane.object3D.updateMatrix();
                    aPlane.object3D.matrixAutoUpdate = false; // Evitar que AR.js sobrescriba
                    log('üîß Matrix transform aplicado directamente - X = 300');
                }
                
                // M√©todo 2: Configurar A-Frame X = 300 con tama√±o reducido
                aPlane.setAttribute('position', '300 0 0.1');
                aPlane.setAttribute('width', '150'); // Reducido de 200 a 150
                aPlane.setAttribute('height', '267'); // Reducido de 356 a 267
                aPlane.setAttribute('scale', '2 2 2'); // Escala reducida
                aPlane.setAttribute('rotation', '-90 0 0');
                aPlane.setAttribute('visible', 'true');
                
                // M√©todo 3: Forzar posici√≥n cada frame X = 300
                const forcePositionLoop = () => {
                    if (aPlane && aPlane.object3D) {
                        aPlane.object3D.position.x = 300; // X = 300
                        aPlane.object3D.position.y = 0;
                        aPlane.object3D.position.z = 0.1;
                        aPlane.object3D.updateMatrix();
                    }
                    requestAnimationFrame(forcePositionLoop);
                };
                forcePositionLoop();
                
                log('‚úÖ Video ajustado a posici√≥n - X = 300');
                log('üîÑ Posici√≥n se fuerza cada frame para mantener (300,0,0.1)');
                
                return true;
            }
            return false;
        }
        
        // Forzar posici√≥n cada segundo hasta que funcione
        let positionForced = false;
        const forceInterval = setInterval(() => {
            if (!positionForced) {
                if (forceVideoPosition()) {
                    positionForced = true;
                    log('‚úÖ Posici√≥n del video forzada exitosamente');
                    clearInterval(forceInterval);
                }
            }
        }, 1000);
        
        // Tambi√©n forzar cuando la escena est√© cargada
        document.querySelector('a-scene').addEventListener('loaded', () => {
            setTimeout(() => {
                forceVideoPosition();
            }, 2000);
        });
        
        // Registrar componente videohandler seg√∫n documentaci√≥n AR.js
         AFRAME.registerComponent('videohandler', {
             init: function () {
                 var marker = this.el;
                 this.vid = document.querySelector("#vid");
                 
                 log('üé¨ VideoHandler: Componente inicializado');
                 
                 marker.addEventListener('markerFound', function () {
                     log('üéØ VideoHandler: Marcador encontrado - reproduciendo video');
                     updateTrackingStatus('‚úÖ Marcador detectado');
                     if (this.vid) {
                         this.vid.muted = true;
                         this.vid.playsInline = true;
                         this.vid.play().then(() => {
                             log('‚úÖ VideoHandler: Video reproduci√©ndose');
                             
                             // Ajustar tama√±o del plano al marcador
                              const aPlane = document.querySelector('#video-plane');
                              
                               if (aPlane) {
                                    log('üìè AJUSTANDO video a posici√≥n - X = 300');
                                    
                                    // Configurar propiedades A-Frame X = 300 con tama√±o reducido
                                    aPlane.setAttribute('width', '150'); // Reducido de 200 a 150
                                    aPlane.setAttribute('height', '267'); // Reducido de 356 a 267
                                    aPlane.setAttribute('position', '300 0 0.1'); // X = 300
                                    aPlane.setAttribute('scale', '2 2 2'); // Escala reducida
                                    aPlane.setAttribute('rotation', '-90 0 0');
                                    aPlane.setAttribute('visible', 'true');
                                    
                                    // FORZAR matrix transform directo en Three.js X = 300
                                    if (aPlane.object3D) {
                                        // Resetear matriz y aplicar transformaciones directas
                                        aPlane.object3D.matrix.identity();
                                        aPlane.object3D.position.set(300, 0, 0.1); // X = 300
                                        aPlane.object3D.rotation.set(-Math.PI/2, 0, 0);
                                        aPlane.object3D.scale.set(2, 2, 2); // Escala reducida
                                        aPlane.object3D.updateMatrix();
                                        aPlane.object3D.matrixAutoUpdate = false;
                                        
                                        log('üîß Matrix transform directo aplicado en videohandler - X = 300');
                                        
                                        // Loop continuo para mantener posici√≥n X = 300
                                        const maintainPosition = () => {
                                            if (aPlane && aPlane.object3D) {
                                                aPlane.object3D.position.set(300, 0, 0.1); // X = 300
                                                aPlane.object3D.updateMatrix();
                                            }
                                            requestAnimationFrame(maintainPosition);
                                        };
                                        maintainPosition();
                                    }
                                    
                                    log('‚úÖ Video ajustado en videohandler - X = 300');
                                }
                             
                         }).catch(e => {
                             log('‚ùå VideoHandler: Error reproduciendo - ' + e.message);
                         });
                     }
                 }.bind(this));
         
                 marker.addEventListener('markerLost', function() {
                     log('‚ùå VideoHandler: Marcador perdido - pausando video');
                     updateTrackingStatus('‚ùå Marcador perdido');
                     if (this.vid) {
                         this.vid.pause();
                         this.vid.currentTime = 0;
                     }
                 }.bind(this));
             }
         });
        
        // Eventos de AR globales como fallback
        document.addEventListener('markerFound', () => {
            updateTrackingStatus('‚úÖ Marcador detectado');
            log('üéØ Marcador NFT encontrado!');
        });
        
        document.addEventListener('markerLost', () => {
            updateTrackingStatus('‚ùå Marcador perdido');
            log('‚ùå Marcador NFT perdido');
        });
        
        // Eventos de A-Frame
        document.querySelector('a-scene').addEventListener('loaded', () => {
            updateStatus('‚úÖ A-Frame cargado');
            log('‚úÖ Escena A-Frame cargada');
        });
        
        // Eventos de video
         const video = document.getElementById('vid');
         
         // Pre-cargar el video inmediatamente
         video.load();
         
         video.addEventListener('loadstart', () => log('üé¨ Video: Iniciando carga'));
         video.addEventListener('loadedmetadata', () => {
             log('üìä Video: Metadatos cargados - ' + video.duration.toFixed(2) + 's');
             // Intentar reproducir tan pronto como tengamos metadatos
             video.muted = true;
             video.playsInline = true;
             video.play().catch(() => log('‚ö†Ô∏è Autoplay temprano bloqueado'));
         });
         video.addEventListener('loadeddata', () => log('‚úÖ Video: Datos cargados'));
         video.addEventListener('canplay', () => {
             log('‚ñ∂Ô∏è Video: Listo para reproducir');
             // Intentar reproducir autom√°ticamente cuando est√© listo
             video.muted = true;
             video.playsInline = true;
             video.play().catch(() => log('‚ö†Ô∏è Autoplay bloqueado, esperando interacci√≥n'));
         });
         video.addEventListener('canplaythrough', () => {
             log('üöÄ Video: Completamente cargado');
             video.muted = true;
             video.playsInline = true;
             video.play().catch(() => log('‚ö†Ô∏è Autoplay final bloqueado'));
         });
         video.addEventListener('play', () => log('‚ñ∂Ô∏è Video: Reproduciendo'));
         video.addEventListener('pause', () => log('‚è∏Ô∏è Video: Pausado'));
         video.addEventListener('ended', () => log('üîÑ Video: Terminado, reiniciando loop'));
         video.addEventListener('error', (e) => {
             const error = e.target.error;
             if (error) {
                 log('‚ùå Video error code: ' + error.code);
                 log('‚ùå Video error message: ' + error.message);
                 switch(error.code) {
                     case 1:
                         log('‚ùå MEDIA_ERR_ABORTED: Reproducci√≥n abortada');
                         break;
                     case 2:
                         log('‚ùå MEDIA_ERR_NETWORK: Error de red');
                         break;
                     case 3:
                         log('‚ùå MEDIA_ERR_DECODE: Error de decodificaci√≥n');
                         break;
                     case 4:
                         log('‚ùå MEDIA_ERR_SRC_NOT_SUPPORTED: Formato no soportado');
                         break;
                 }
             }
             log('‚ùå Video src: ' + video.src);
             log('‚ùå Video readyState: ' + video.readyState);
             log('‚ùå Video networkState: ' + video.networkState);
         });
        
        // Verificar estado del video peri√≥dicamente
        setInterval(() => {
            if (video) {
                const state = {
                    currentTime: video.currentTime.toFixed(2),
                    duration: video.duration ? video.duration.toFixed(2) : 'N/A',
                    paused: video.paused,
                    muted: video.muted,
                    readyState: video.readyState,
                    networkState: video.networkState
                };
                console.log('üìä Video state:', state);
            }
        }, 5000);
        
        // Inicializaci√≥n
        window.addEventListener('load', async () => {
            updateStatus('Verificando c√°mara...');
            const cameraOk = await checkCamera();
            
            if (cameraOk) {
                updateStatus('‚úÖ Listo para AR');
                log('‚úÖ Sistema listo. Apunta la c√°mara a la imagen de pinball de AR.js');
                log('üì± Imagen de prueba: https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.4.5/data/images/pinball.jpg');
                
                // Fix camera video after AR.js initializes
                setTimeout(() => {
                    fixCameraVideo();
                }, 2000);
            } else {
                updateStatus('‚ùå Error de c√°mara');
            }
        });
        
        // Function to fix camera video display
        function fixCameraVideo() {
            let attempts = 0;
            const maxAttempts = 20;
            
            function tryFix() {
                attempts++;
                
                // Find the AR.js injected video element
                const arVideo = document.getElementById('arjs-video');
                if (arVideo) {
                    log('üé• Found AR video element, applying fixes');
                    
                    // Ensure video properties
                    arVideo.setAttribute('playsinline', 'true');
                    arVideo.setAttribute('webkit-playsinline', 'true');
                    arVideo.setAttribute('muted', 'true');
                    arVideo.setAttribute('autoplay', 'true');
                    arVideo.playsInline = true;
                    arVideo.muted = true;
                    arVideo.autoplay = true;
                    
                    // Force video styles to be visible
                     arVideo.style.setProperty('position', 'fixed', 'important');
                     arVideo.style.setProperty('top', '0', 'important');
                     arVideo.style.setProperty('left', '0', 'important');
                     arVideo.style.setProperty('width', '100vw', 'important');
                     arVideo.style.setProperty('height', '100vh', 'important');
                     arVideo.style.setProperty('object-fit', 'cover', 'important');
                     arVideo.style.setProperty('z-index', '-1', 'important');
                     arVideo.style.setProperty('display', 'block', 'important');
                     arVideo.style.setProperty('visibility', 'visible', 'important');
                     arVideo.style.setProperty('opacity', '1', 'important');
                     arVideo.style.setProperty('background', 'black', 'important');
                     arVideo.style.setProperty('margin', '0', 'important');
                     arVideo.style.setProperty('padding', '0', 'important');
                     arVideo.style.setProperty('border', 'none', 'important');
                     arVideo.style.setProperty('outline', 'none', 'important');
                    
                    // Try to play the video
                    arVideo.play().catch(() => {
                        log('‚ö†Ô∏è Video autoplay failed, waiting for user interaction');
                    });
                    
                    return;
                }
                
                // Find the canvas and ensure it's transparent
                 const canvas = document.querySelector('canvas.a-canvas');
                 if (canvas) {
                     log('üé® Found A-Frame canvas, making it transparent');
                     canvas.style.setProperty('background', 'transparent', 'important');
                     canvas.style.setProperty('background-color', 'transparent', 'important');
                     canvas.style.setProperty('background-image', 'none', 'important');
                     canvas.style.setProperty('z-index', '1', 'important');
                     canvas.style.setProperty('position', 'fixed', 'important');
                     canvas.style.setProperty('top', '0', 'important');
                     canvas.style.setProperty('left', '0', 'important');
                     canvas.style.setProperty('width', '100vw', 'important');
                     canvas.style.setProperty('height', '100vh', 'important');
                     canvas.style.setProperty('margin', '0', 'important');
                     canvas.style.setProperty('padding', '0', 'important');
                     canvas.style.setProperty('border', 'none', 'important');
                     canvas.style.setProperty('pointer-events', 'auto', 'important');
                 }
                 
                 // Also try to find any other canvas elements
                 const allCanvases = document.querySelectorAll('canvas');
                 allCanvases.forEach((canvasEl, index) => {
                     log(`üé® Found canvas ${index + 1}, making it transparent`);
                     canvasEl.style.setProperty('background', 'transparent', 'important');
                     canvasEl.style.setProperty('background-color', 'transparent', 'important');
                     canvasEl.style.setProperty('background-image', 'none', 'important');
                 });
                 
                 // Remove any A-Frame UI elements that might be white
                 const aframeUI = document.querySelectorAll('.a-enter-vr, .a-orientation-modal, .a-dialog');
                 aframeUI.forEach(el => {
                     el.style.display = 'none';
                 });
                 
                 // Ensure the scene itself has no white background
                 const scene = document.querySelector('a-scene');
                 if (scene) {
                     scene.style.setProperty('background', 'transparent', 'important');
                     scene.style.setProperty('background-color', 'transparent', 'important');
                     scene.style.setProperty('position', 'fixed', 'important');
                     scene.style.setProperty('top', '0', 'important');
                     scene.style.setProperty('left', '0', 'important');
                     scene.style.setProperty('width', '100vw', 'important');
                     scene.style.setProperty('height', '100vh', 'important');
                     scene.style.setProperty('margin', '0', 'important');
                     scene.style.setProperty('padding', '0', 'important');
                     
                     // Remove any background attribute that might be causing white screen
                     scene.removeAttribute('background');
                     
                     // Force renderer to not clear with white
                     const renderer = scene.renderer;
                     if (renderer && renderer.domElement) {
                         renderer.domElement.style.background = 'transparent';
                         renderer.setClearColor(0x000000, 0); // Transparent black
                     }
                 }
                 
                 // Force WebGL context to be transparent
                 setTimeout(() => {
                     const canvases = document.querySelectorAll('canvas');
                     canvases.forEach(canvas => {
                         // Remove any problematic WebGL manipulation
                         canvas.style.setProperty('background', 'transparent', 'important');
                         canvas.style.setProperty('background-color', 'transparent', 'important');
                         canvas.style.setProperty('z-index', '1', 'important');
                         
                         // Ensure canvas doesn't block camera
                         canvas.style.setProperty('pointer-events', 'none', 'important');
                         canvas.style.setProperty('mix-blend-mode', 'multiply', 'important');
                     });
                     
                     // Force AR.js video to be visible
                     const arVideo = document.getElementById('arjs-video');
                     if (arVideo) {
                         log('üé• Forcing AR video visibility');
                         arVideo.style.setProperty('z-index', '-1', 'important');
                         arVideo.style.setProperty('display', 'block', 'important');
                         arVideo.style.setProperty('visibility', 'visible', 'important');
                         arVideo.style.setProperty('opacity', '1', 'important');
                     }
                 }, 2000);
                
                if (attempts < maxAttempts) {
                    setTimeout(tryFix, 500);
                } else {
                    log('‚ö†Ô∏è Could not find AR video element after ' + maxAttempts + ' attempts');
                }
            }
            
            tryFix();
        }
        
        // Log de errores globales
        window.addEventListener('error', (e) => {
            log('‚ùå Error global: ' + e.message);
        });
        
        // Log inicial
        log('üöÄ Iniciando test AR simple...');
    </script>
</body>
</html>